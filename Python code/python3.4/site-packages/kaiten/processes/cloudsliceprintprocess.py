import json
import urllib.parse
import kaiten.error
from kaiten.processes.externalprintprocess import ExternalPrintProcess

class CloudSlicePrintProcess(ExternalPrintProcess):
    def __init__(self, *args, **kwargs):
        super(CloudSlicePrintProcess, self).__init__(*args, **kwargs)
        self._cloud_slice_print_steps = kaiten.enum.enum("cloud_slice_print_steps",
            "awaitingcloudslice")
        self._response = None
        self._awaiting_response = False
        self._error_response = False

    def _success_callback(self, response):
        self._response = response

    def _error_callback(self, **kwargs):
        self._log.error("Error during HTTP request {0}: {1}".format(self._url, kwargs))
        self._error_response = True
        

    def _await_slice(self):
        url = urllib.parse.urlparse(self._url)
        path = "{0}?{1}".format(url.path, url.query)
        while not self._error_response:
            # If we don't currently have a response or are waiting on a response
            # then let's send out a request
            if not self._awaiting_response and not self._response:
                self._request = self._machine_manager._server.http_request(
                    url.netloc,
                    path,
                    "GET",
                    params={},
                    https=(url.scheme == "https"),
                    token=None,
                    success_callback=self._success_callback,
                    error_callback=self._error_callback,
                    timeout=60,
                )
                # We don't want to spam requests while waiting for a response
                self._awaiting_response = True
            if self._response:
                json_res = json.loads(self._response)
                self._progress = json_res.get('progress', 0)
                if json_res.get('failed', False):
                    self._error_response = True
                    break
                elif json_res.get('completed', False):
                    # If our slice is completed then let's grab the resultant
                    # .makerbot URL and get on with it
                    sliced_url = json_res.get('result', None)
                    self._log.debug('sliced url: {0}'.format(sliced_url))
                    if not sliced_url:
                        raise kaiten.error.ThingiverseException
                    self._url = sliced_url
                    break
                self._response = None
                self._awaiting_response = False
            yield

    def _set_filepath(self):
        """
        Override implementation
        """
        if not self._machine_manager._server.is_online():
            self._log.error("Attempted cloud slice print while offline")
            yield kaiten.error.printing_network_error
        self._step_change(self._cloud_slice_print_steps.awaitingcloudslice)
        self._machine_manager._server.mixpanel_event("cloud_slice_print_started",
            self._client, url=self._url)
        #Let's wait till the slice is complete
        yield from self._await_slice()
        if self._error_response:
            yield kaiten.error.cloud_slicing_error
        # Then call into ExternalPrintProcess._set_filepath to leverage the
        # downloading logic there
        # We don't worry about if self._url is valid since
        # ExternalPrintProcess handles that check
        yield from super(CloudSlicePrintProcess, self)._set_filepath()
